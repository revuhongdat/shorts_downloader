import tkinter as tk
from tkinter import messagebox, scrolledtext, ttk, filedialog
import yt_dlp
import os
from datetime import datetime, timedelta
import threading

class ShortsDownloader:
    def __init__(self, root):
        self.root = root
        self.root.title("Shorts YouTube Downloader - by Dat0o")
        self.root.geometry("1100x820")
        
        self.shorts_list = []
        self.download_path = "./shorts_downloaded"
        self.cookies_path = ""  # t√πy ch·ªçn
        
        self.setup_ui()
        self.configure_tree_style()
    
    # ------------- UI helpers (thread-safe) -------------
    def safe_ui(self, func, *args, **kwargs):
        self.root.after(0, lambda: func(*args, **kwargs))
    
    def log(self, message):
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_text.see(tk.END)
    
    def configure_tree_style(self):
        style = ttk.Style()
        style.configure("Bordered.Treeview",
                        borderwidth=1, relief="solid",
                        rowheight=25, fieldbackground="white")
        style.configure("Bordered.Treeview.Heading",
                        borderwidth=1, relief="solid",
                        background="lightgray", font=('Arial', 9, 'bold'))
        style.configure("Large.Horizontal.TProgressbar",
                        troughcolor='#e0e0e0', background='#4CAF50',
                        lightcolor='#4CAF50', darkcolor='#2E7D32',
                        borderwidth=1, relief='solid')
        style.configure("Small.Horizontal.TProgressbar",
                        troughcolor='#e0e0e0', background='#2196F3',
                        lightcolor='#2196F3', darkcolor='#1976D2',
                        borderwidth=1, relief='solid')
        style.map("Bordered.Treeview", background=[('selected', '#0078d4')])
        style.map("Bordered.Treeview.Heading", background=[('active', '#e1e1e1')])
    
    def setup_ui(self):
        main_frame = tk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
        
        
        # URL
        url_frame = tk.LabelFrame(main_frame, text="üì∫ K√™nh YouTube", font=('Arial', 10, 'bold'), padx=10, pady=8)
        url_frame.pack(fill=tk.X, pady=(0, 10))
        tk.Label(url_frame, text="Link k√™nh (v√≠ d·ª•: https://www.youtube.com/@abc):").pack(anchor=tk.W, pady=(0, 5))
        self.link_var = tk.StringVar()
        url_entry = tk.Entry(url_frame, textvariable=self.link_var, width=80, font=('Arial', 10))
        url_entry.pack(fill=tk.X)
        
        # Combined filters + settings
        combined_frame = tk.Frame(main_frame)
        combined_frame.pack(fill=tk.X, pady=(10, 10))
        
        # --- Time filter
        filter_frame = tk.LabelFrame(combined_frame, text="üìÖ Kho·∫£ng th·ªùi gian", font=('Arial', 10, 'bold'), padx=10, pady=8)
        filter_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        time_options_frame = tk.Frame(filter_frame); time_options_frame.pack(fill=tk.X, pady=2)
        self.time_filter_var = tk.StringVar(value="30d")
        time_options = [("T·∫•t c·∫£", "all"), ("24h", "1d"), ("7d", "7d"), ("30d", "30d"),
                        ("90d", "90d"), ("1y", "1y"), ("T√πy ch·ªçn", "custom")]
        for text, value in time_options:
            tk.Radiobutton(time_options_frame, text=text, variable=self.time_filter_var, value=value) \
                .pack(side=tk.LEFT, padx=3)
        
        custom_row = tk.Frame(filter_frame); custom_row.pack(fill=tk.X, pady=(8, 2))
        tk.Label(custom_row, text="T·ª´ ng√†y:", width=8, anchor='w').pack(side=tk.LEFT)
        self.from_date_var = tk.StringVar(value=(datetime.now() - timedelta(days=30)).strftime("%d/%m/%Y"))
        tk.Entry(custom_row, textvariable=self.from_date_var, width=12, font=('Arial', 9)).pack(side=tk.LEFT, padx=(2, 8))
        tk.Label(custom_row, text="ƒê·∫øn ng√†y:", width=8, anchor='w').pack(side=tk.LEFT)
        self.to_date_var = tk.StringVar(value=datetime.now().strftime("%d/%m/%Y"))
        tk.Entry(custom_row, textvariable=self.to_date_var, width=12, font=('Arial', 9)).pack(side=tk.LEFT, padx=(2, 8))
        tk.Label(custom_row, text="(dd/mm/yyyy)", font=('Arial', 7), fg='gray').pack(side=tk.LEFT, padx=(5,0))
        
        # --- Settings
        settings_frame = tk.LabelFrame(combined_frame, text="‚öôÔ∏è C√†i ƒë·∫∑t t·∫£i xu·ªëng", font=('Arial', 10, 'bold'), padx=10, pady=8)
        settings_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        path_row = tk.Frame(settings_frame); path_row.pack(fill=tk.X, pady=2)
        tk.Label(path_row, text="üìÅ Th∆∞ m·ª•c:", width=12, anchor='w').pack(side=tk.LEFT)
        self.path_var = tk.StringVar(value=self.download_path)
        tk.Entry(path_row, textvariable=self.path_var, font=('Arial', 9)).pack(side=tk.LEFT, padx=(2, 5), fill=tk.X, expand=True)
        tk.Button(path_row, text="...", command=self.choose_directory, width=3, font=('Arial', 8)).pack(side=tk.LEFT)
        
        quality_row = tk.Frame(settings_frame); quality_row.pack(fill=tk.X, pady=(8, 2))
        tk.Label(quality_row, text="üé• Ch·∫•t l∆∞·ª£ng:", width=12, anchor='w').pack(side=tk.LEFT)
        self.quality_var = tk.StringVar(value="720p")
        ttk.Combobox(quality_row, textvariable=self.quality_var,
                     values=["T·ªët nh·∫•t","1080p","720p","480p","360p","Nh·ªè nh·∫•t"],
                     state="readonly", width=10, font=('Arial', 9)).pack(side=tk.LEFT, padx=(2, 10))
        
        tk.Label(quality_row, text="üìÑ Format:", width=8, anchor='w').pack(side=tk.LEFT)
        self.format_var = tk.StringVar(value="mp4")
        ttk.Combobox(quality_row, textvariable=self.format_var,
                     values=["mp4","webm","mkv","avi"],
                     state="readonly", width=8, font=('Arial', 9)).pack(side=tk.LEFT, padx=(2, 10))
        
        tk.Label(quality_row, text="üîä Audio:", width=8, anchor='w').pack(side=tk.LEFT)
        self.audio_var = tk.StringVar(value="C√≥")
        ttk.Combobox(quality_row, textvariable=self.audio_var,
                     values=["C√≥","Kh√¥ng","Ch·ªâ audio"],
                     state="readonly", width=10, font=('Arial', 9)).pack(side=tk.LEFT, padx=(2, 10))
        
        # Optional cookies
        cookie_row = tk.Frame(settings_frame); cookie_row.pack(fill=tk.X, pady=(8,2))
        tk.Label(cookie_row, text="üç™ Cookies:", width=12, anchor='w').pack(side=tk.LEFT)
        self.cookies_var = tk.StringVar(value="")
        tk.Entry(cookie_row, textvariable=self.cookies_var, font=('Arial', 9)).pack(side=tk.LEFT, padx=(2,5), fill=tk.X, expand=True)
        tk.Button(cookie_row, text="Ch·ªçn", command=self.choose_cookies, width=6).pack(side=tk.LEFT)
        tk.Label(settings_frame, text="(Tu·ª≥ ch·ªçn, d√πng khi k√™nh r·∫•t l·ªõn ho·∫∑c b·ªã ch·∫∑n)", fg="#666", font=('Arial', 8)).pack(anchor='w')
        
        # Controls
        control_frame = tk.LabelFrame(main_frame, text="üéÆ ƒêi·ªÅu khi·ªÉn", font=('Arial', 10, 'bold'), padx=10, pady=8)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        action_row = tk.Frame(control_frame); action_row.pack(fill=tk.X, pady=2)
        tk.Button(action_row, text="üìã L·∫•y danh s√°ch Shorts",
                  command=self.get_shorts_list, width=20, height=1,
                  bg='#4CAF50', fg='white', font=('Arial', 9, 'bold')).pack(side=tk.LEFT, padx=(0, 10))
        tk.Button(action_row, text="üíæ T·∫£i t·∫•t c·∫£",
                  command=self.download_all, width=15, height=1,
                  bg='#2196F3', fg='white', font=('Arial', 9, 'bold')).pack(side=tk.LEFT, padx=(0, 10))
        tk.Frame(action_row).pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.videos_count_label = tk.Label(action_row, text="", font=('Arial', 9), fg='#666')
        self.videos_count_label.pack(side=tk.RIGHT)
        
        range_row = tk.Frame(control_frame); range_row.pack(fill=tk.X, pady=(8, 2))
        tk.Label(range_row, text="üìä T·∫£i theo kho·∫£ng:", font=('Arial', 9, 'bold')).pack(side=tk.LEFT)
        tk.Label(range_row, text="T·ª´ s·ªë:").pack(side=tk.LEFT, padx=(20, 5))
        self.start_var = tk.StringVar(value="1")
        tk.Entry(range_row, textvariable=self.start_var, width=6, justify='center').pack(side=tk.LEFT, padx=(0, 10))
        tk.Label(range_row, text="ƒë·∫øn s·ªë:").pack(side=tk.LEFT, padx=(0, 5))
        self.end_var = tk.StringVar(value="10")
        tk.Entry(range_row, textvariable=self.end_var, width=6, justify='center').pack(side=tk.LEFT, padx=(0, 15))
        tk.Button(range_row, text="‚ñ∂Ô∏è T·∫£i theo l·ª±a ch·ªçn",
                  command=self.download_range, width=18,
                  bg='#FF9800', fg='white', font=('Arial', 9, 'bold')).pack(side=tk.LEFT)
        
        # Progress
        progress_frame = tk.LabelFrame(main_frame, text="üìà Ti·∫øn tr√¨nh", font=('Arial', 10, 'bold'), padx=10, pady=8)
        progress_frame.pack(fill=tk.X, pady=(0, 10))
        tk.Label(progress_frame, text="T·ªïng th·ªÉ:", font=('Arial', 9, 'bold')).pack(anchor=tk.W)
        overall_container = tk.Frame(progress_frame, height=25)
        overall_container.pack(fill=tk.X, pady=(2, 5))
        overall_container.pack_propagate(False)
        self.overall_progress = ttk.Progressbar(overall_container, mode='determinate',
                                                style="Large.Horizontal.TProgressbar")
        self.overall_progress.pack(fill=tk.BOTH, expand=True, pady=3)
        self.overall_status = tk.Label(progress_frame, text="S·∫µn s√†ng", anchor=tk.W, font=('Arial', 9))
        self.overall_status.pack(anchor=tk.W)
        
        tk.Label(progress_frame, text="Video hi·ªán t·∫°i:", font=('Arial', 9, 'bold')).pack(anchor=tk.W, pady=(8, 0))
        current_container = tk.Frame(progress_frame, height=20)
        current_container.pack(fill=tk.X, pady=(2, 5))
        current_container.pack_propagate(False)
        self.current_progress = ttk.Progressbar(current_container, mode='determinate',
                                                style="Small.Horizontal.TProgressbar")
        self.current_progress.pack(fill=tk.BOTH, expand=True, pady=2)
        self.current_status = tk.Label(progress_frame, text="", anchor=tk.W, font=('Arial', 8))
        self.current_status.pack(anchor=tk.W)
        
        # List
        list_frame = tk.LabelFrame(main_frame, text="üìã Danh s√°ch Shorts (‚â§180s)", font=('Arial', 10, 'bold'), padx=5, pady=5)
        list_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        tree_frame = tk.Frame(list_frame, relief=tk.SUNKEN, borderwidth=1)
        tree_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        columns = ('STT', 'Ti√™u ƒë·ªÅ', 'Th·ªùi l∆∞·ª£ng', 'Ng√†y t·∫£i l√™n', 'Tr·∫°ng th√°i')
        self.tree = ttk.Treeview(tree_frame, columns=columns, show='headings', height=8, style="Bordered.Treeview")
        self.tree.heading('STT', text='STT', anchor='center')
        self.tree.heading('Ti√™u ƒë·ªÅ', text='Ti√™u ƒë·ªÅ', anchor='w')
        self.tree.heading('Th·ªùi l∆∞·ª£ng', text='Th·ªùi l∆∞·ª£ng (s)', anchor='center')
        self.tree.heading('Ng√†y t·∫£i l√™n', text='Ng√†y t·∫£i l√™n', anchor='center')
        self.tree.heading('Tr·∫°ng th√°i', text='Tr·∫°ng th√°i', anchor='center')
        self.tree.column('STT', width=50, anchor='center', minwidth=50)
        self.tree.column('Ti√™u ƒë·ªÅ', width=450, anchor='w', minwidth=250)
        self.tree.column('Th·ªùi l∆∞·ª£ng', width=100, anchor='center', minwidth=80)
        self.tree.column('Ng√†y t·∫£i l√™n', width=120, anchor='center', minwidth=100)
        self.tree.column('Tr·∫°ng th√°i', width=120, anchor='center', minwidth=100)
        v_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.tree.yview)
        h_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.HORIZONTAL, command=self.tree.xview)
        self.tree.configure(yscrollcommand=v_scrollbar.set, xscrollcommand=h_scrollbar.set)
        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scrollbar.grid(row=0, column=1, sticky="ns")
        h_scrollbar.grid(row=1, column=0, sticky="ew")
        tree_frame.grid_rowconfigure(0, weight=1); tree_frame.grid_columnconfigure(0, weight=1)
        
        self.tree.tag_configure('oddrow', background='#f8f9fa')
        self.tree.tag_configure('evenrow', background='white')
        self.tree.tag_configure('pending', foreground='#6c757d')
        self.tree.tag_configure('downloading', foreground='#0066cc', background='#e3f2fd')
        self.tree.tag_configure('completed', foreground='#28a745', background='#d4edda')
        self.tree.tag_configure('error', foreground='#dc3545', background='#f8d7da')
        
        # Log
        log_frame = tk.LabelFrame(main_frame, text="üìù Nh·∫≠t k√Ω ho·∫°t ƒë·ªông", font=('Arial', 10, 'bold'), padx=5, pady=5)
        log_frame.pack(fill=tk.X)
        self.log_text = scrolledtext.ScrolledText(log_frame, height=6, width=80, font=('Consolas', 9), bg='#f8f9fa')
        self.log_text.pack(fill=tk.BOTH, padx=5, pady=5)
    
    # ------------- Utils -------------
    def choose_directory(self):
        directory = filedialog.askdirectory(initialdir=self.download_path)
        if directory:
            self.download_path = directory
            self.path_var.set(directory)
            self.safe_ui(self.log, f"üìÅ ƒê√£ ch·ªçn th∆∞ m·ª•c: {directory}")
    
    def choose_cookies(self):
        path = filedialog.askopenfilename(title="Ch·ªçn cookies.txt",
                                          filetypes=[("Text", "*.txt"), ("All files", "*.*")])
        if path:
            self.cookies_path = path
            self.cookies_var.set(path)
            self.safe_ui(self.log, f"üç™ D√πng cookies: {path}")
    
    def parse_date_string(self, date_str):
        try:
            return datetime.strptime(date_str, "%d/%m/%Y")
        except ValueError:
            return None
    
    def get_time_range(self):
        filter_type = self.time_filter_var.get()
        now = datetime.now()
        if filter_type == "all":
            return None, None, "t·∫•t c·∫£ th·ªùi gian"
        elif filter_type == "custom":
            from_date = self.parse_date_string(self.from_date_var.get())
            to_date = self.parse_date_string(self.to_date_var.get())
            if not from_date or not to_date:
                messagebox.showwarning("‚ùå L·ªói", "ƒê·ªãnh d·∫°ng ng√†y kh√¥ng h·ª£p l·ªá! S·ª≠ d·ª•ng dd/mm/yyyy")
                return None, None, None
            if from_date > to_date:
                messagebox.showwarning("‚ùå L·ªói", "Ng√†y b·∫Øt ƒë·∫ßu ph·∫£i nh·ªè h∆°n ng√†y k·∫øt th√∫c!")
                return None, None, None
            to_date = to_date.replace(hour=23, minute=59, second=59)
            return from_date, to_date, f"t·ª´ {from_date.strftime('%d/%m/%Y')} ƒë·∫øn {to_date.strftime('%d/%m/%Y')}"
        else:
            mapping = {
                "1d": (now - timedelta(days=1), "24 gi·ªù qua"),
                "7d": (now - timedelta(days=7), "7 ng√†y qua"),
                "30d": (now - timedelta(days=30), "30 ng√†y qua"),
                "90d": (now - timedelta(days=90), "90 ng√†y qua"),
                "1y": (now - timedelta(days=365), "1 nƒÉm qua"),
            }
            cutoff, name = mapping[filter_type]
            return cutoff, now, name
    
    def is_video_in_time_range(self, up_dt, from_date, to_date):
        if from_date is None and to_date is None:
            return True
        if up_dt is None:
            # Kh√¥ng bi·∫øt ng√†y ‚Üí ƒê·ª™NG lo·∫°i
            return True
        if from_date and to_date:
            return from_date <= up_dt <= to_date
        if from_date:
            return up_dt >= from_date
        return True
    
    def get_shorts_url(self, video_id):
        return f"https://www.youtube.com/shorts/{video_id}"
    
    # ------------- Fetch Shorts list -------------
    def get_channel_videos_with_ytdlp(self, channel_url, limit=2000):
        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'extract_flat': True,          # l·∫•y danh s√°ch nhanh, s√¢u
            'playlistend': limit,
            'ignoreerrors': True,
            'retries': 5,
            'extractor_args': {
                'youtube': {
                    'tab': ['shorts'],     # √âP tab Shorts
                }
            }
        }
        if self.cookies_path and os.path.exists(self.cookies_path):
            ydl_opts['cookiefile'] = self.cookies_path
        
        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                self.safe_ui(self.log, "üîÑ ƒêang l·∫•y tab Shorts c·ªßa k√™nh...")
                url = channel_url.rstrip('/')
                if not url.endswith('/shorts'):
                    url = url + '/shorts'
                info = ydl.extract_info(url, download=False)
                if not info:
                    return []
                return info.get('entries', [])
        except Exception as e:
            self.safe_ui(self.log, f"‚ùå L·ªói yt-dlp khi l·∫•y danh s√°ch: {e}")
            return []
    
    def update_tree_status(self, index, status):
        items = self.tree.get_children()
        if 0 <= index < len(items):
            item = items[index]
            values = list(self.tree.item(item)['values'])
            values[4] = status
            if status == "Ch∆∞a t·∫£i":
                tag = 'pending'
            elif status == "ƒêang t·∫£i...":
                tag = 'downloading'
            elif status == "Ho√†n th√†nh":
                tag = 'completed'
            elif status == "L·ªói":
                tag = 'error'
            else:
                tag = 'evenrow' if index % 2 == 0 else 'oddrow'
            self.tree.item(item, values=values, tags=(tag,))
    
    def get_shorts_list(self):
        url = self.link_var.get().strip()
        if not (url.startswith("https://www.youtube.com/@") or "youtube.com/channel/" in url):
            messagebox.showwarning("‚ùå L·ªói", "Vui l√≤ng nh·∫≠p link k√™nh d·∫°ng https://www.youtube.com/@username ho·∫∑c /channel/ID")
            return
        
        from_date, to_date, range_name = self.get_time_range()
        if range_name is None:
            return
        
        self.safe_ui(self.log, f"üîç L·∫•y video ‚â§180s {range_name}...")
        self.safe_ui(self.overall_status.config, text="üîç ƒêang qu√©t k√™nh...")
        self.safe_ui(self.videos_count_label.config, text="")
        
        def fetch_shorts():
            try:
                self.safe_ui(lambda: [self.tree.delete(i) for i in self.tree.get_children()])
                self.shorts_list = []
                
                videos = self.get_channel_videos_with_ytdlp(url, limit=2000)
                if not videos:
                    self.safe_ui(self.log, "‚ùå Kh√¥ng th·ªÉ l·∫•y danh s√°ch video t·ª´ k√™nh!")
                    messagebox.showerror("‚ùå L·ªói", "Kh√¥ng th·ªÉ l·∫•y danh s√°ch video t·ª´ k√™nh!")
                    return
                
                shorts_data = []
                checked_count = 0
                skipped_by_time = 0
                skipped_by_duration = 0
                
                self.safe_ui(self.log, f"üìä ƒê√£ l·∫•y {len(videos)} m·ª•c, b·∫Øt ƒë·∫ßu ph√¢n t√≠ch...")
                
                for video_info in videos:
                    if not video_info:
                        continue
                    checked_count += 1
                    if checked_count % 50 == 0:
                        self.safe_ui(self.log, f"üìä Ph√¢n t√≠ch {checked_count}/{len(videos)}... T√¨m th·∫•y {len(shorts_data)} Shorts")
                    
                    try:
                        # id/title
                        vid = video_info.get('id') or video_info.get('url') or ""
                        if not vid:
                            continue
                        # M·ªôt s·ªë m·ª•c c√≥ 'url' d·∫°ng '/watch?v=XXXX' ‚Üí c·∫Øt id
                        if isinstance(vid, str) and 'watch?v=' in vid:
                            vid = vid.split('watch?v=')[-1].split('&')[0]
                        
                        # duration
                        duration = video_info.get('duration')
                        # N·∫øu kh√¥ng c√≥ duration: v·∫´n nh·∫≠n (Shorts th∆∞·ªùng <=60/90s)
                        if duration is not None and duration > 180:
                            skipped_by_duration += 1
                            continue
                        
                        # th·ªùi gian
                        upload_date_raw = video_info.get('upload_date')
                        timestamp = video_info.get('timestamp') or video_info.get('release_timestamp')
                        if timestamp:
                            up_dt = datetime.fromtimestamp(timestamp)
                            up_date_str = up_dt.strftime('%Y%m%d')
                        elif upload_date_raw:
                            try:
                                up_dt = datetime.strptime(upload_date_raw, '%Y%m%d')
                                up_date_str = upload_date_raw
                            except Exception:
                                up_dt = None
                                up_date_str = None
                        else:
                            up_dt = None
                            up_date_str = None
                        
                        if not self.is_video_in_time_range(up_dt, from_date, to_date):
                            skipped_by_time += 1
                            continue
                        
                        formatted_date = up_dt.strftime('%d/%m/%Y') if up_dt else '‚Äî'
                        
                        shorts_data.append({
                            'video_id': vid,
                            'title': video_info.get('title', 'Unknown'),
                            'duration': int(duration) if duration is not None else 0,
                            'upload_date': up_date_str or '00000000',
                            'formatted_date': formatted_date,
                            'url': self.get_shorts_url(vid),
                            'watch_url': f"https://www.youtube.com/watch?v={vid}",
                        })
                    
                    except Exception as e:
                        self.safe_ui(self.log, f"‚ö†Ô∏è L·ªói khi ph√¢n t√≠ch video: {e}")
                        continue
                
                # sort: item c√≥ ng√†y l√™n tr∆∞·ªõc, sau ƒë√≥ theo ng√†y gi·∫£m d·∫ßn
                shorts_data.sort(key=lambda x: (x['upload_date'] == '00000000', x['upload_date']), reverse=True)
                self.shorts_list = shorts_data
                
                def fill_tree():
                    for i, short in enumerate(shorts_data, 1):
                        tag = 'evenrow' if i % 2 == 0 else 'oddrow'
                        title = short['title'] or 'Unknown'
                        title = (title[:55] + '...') if len(title) > 55 else title
                        self.tree.insert('', 'end', values=(
                            i, title, short['duration'], short['formatted_date'], "Ch∆∞a t·∫£i"
                        ), tags=(tag,))
                self.safe_ui(fill_tree)
                
                count = len(shorts_data)
                self.safe_ui(self.log, f"üéâ Ho√†n th√†nh! T√¨m th·∫•y {count} Shorts (‚â§180s) {range_name}")
                self.safe_ui(self.log, f"üìä Ph√¢n t√≠ch: {checked_count} m·ª•c | B·ªè qua: {skipped_by_time} (th·ªùi gian) + {skipped_by_duration} (>180s)")
                self.safe_ui(self.overall_status.config, text=f"‚úÖ T√¨m th·∫•y {count} Shorts")
                self.safe_ui(self.videos_count_label.config, text=f"üìä T·ªïng: {count} videos")
                if count:
                    self.safe_ui(self.end_var.set, str(count))
            
            except Exception as e:
                self.safe_ui(self.log, f"‚ùå L·ªói khi l·∫•y danh s√°ch: {e}")
                messagebox.showerror("‚ùå L·ªói", f"L·ªói khi l·∫•y danh s√°ch video: {e}")
                self.safe_ui(self.overall_status.config, text="‚ùå L·ªói khi qu√©t k√™nh")
        
        threading.Thread(target=fetch_shorts, daemon=True).start()
    
    # ------------- Download -------------
    def get_download_format(self):
        quality = self.quality_var.get()
        if quality == "T·ªët nh·∫•t":
            return "bv*+ba/b"
        elif quality == "Nh·ªè nh·∫•t":
            return "worst"
        else:
            h = ''.join(ch for ch in quality if ch.isdigit())
            return f"bv*[height<={h}]+ba/b[height<={h}]"
    
    def progress_hook(self, d):
        if d['status'] == 'downloading':
            try:
                if 'total_bytes' in d and d['total_bytes']:
                    percent = (d['downloaded_bytes'] / d['total_bytes']) * 100
                elif 'total_bytes_estimate' in d and d['total_bytes_estimate']:
                    percent = (d['downloaded_bytes'] / d['total_bytes_estimate']) * 100
                else:
                    percent = 0.0
                
                speed = d.get('speed') or 0
                speed_str = f"{speed/1024/1024:.1f} MB/s" if speed > 1024*1024 else f"{speed/1024:.1f} KB/s"
                
                downloaded = d.get('downloaded_bytes', 0)
                total = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
                if total:
                    size_str = f"{downloaded/1024/1024:.1f}/{total/1024/1024:.1f} MB"
                else:
                    size_str = f"{downloaded/1024/1024:.1f} MB"
                
                self.safe_ui(self.current_progress.configure, value=percent)
                self.safe_ui(self.current_status.config, text=f"üì• {percent:.1f}% - {speed_str} - {size_str}")
            except Exception:
                pass
        
        elif d['status'] == 'finished':
            self.safe_ui(self.current_progress.configure, value=100)
            self.safe_ui(self.current_status.config, text="‚úÖ Ho√†n th√†nh t·∫£i video")
    
    def download_short(self, short_info, index, total_index):
        download_path = self.path_var.get().strip() or self.download_path
        fmt = self.get_download_format()
        audio_choice = self.audio_var.get()
        container = self.format_var.get()
        
        outtmpl = f'{download_path}/%(upload_date,unknown)s_%(title).150B.%(ext)s'
        ydl_opts = {
            'format': ("bestaudio/best" if audio_choice == "Ch·ªâ audio" else fmt),
            'outtmpl': outtmpl,
            'quiet': True,
            'no_warnings': True,
            'progress_hooks': [self.progress_hook],
            'noprogress': True,
            'retries': 5,
            'fragment_retries': 5,
            'concurrent_fragment_downloads': 4,
            'ignoreerrors': False,
        }
        if self.cookies_path and os.path.exists(self.cookies_path):
            ydl_opts['cookiefile'] = self.cookies_path
        
        # Merge/convert (n·∫øu kh√¥ng ph·∫£i "Ch·ªâ audio")
        if audio_choice != "Ch·ªâ audio":
            # G·ª£i √Ω container mong mu·ªën (kh√¥ng c∆∞·ª°ng √©p n·∫øu kh√¥ng h·ªó tr·ª£)
            ydl_opts['merge_output_format'] = container
            # N·∫øu c·∫ßn chuy·ªÉn container:
            if container in ('mp4', 'mkv', 'webm', 'avi'):
                ydl_opts.setdefault('postprocessors', [])
                # Video convertor (ch·ªâ chuy·ªÉn container n·∫øu c·∫ßn)
                ydl_opts['postprocessors'].append({'key': 'FFmpegVideoConvertor', 'preferedformat': container})
        
        try:
            self.safe_ui(self.update_tree_status, index, "ƒêang t·∫£i...")
            short_title = (short_info['title'][:40] + '...') if len(short_info['title']) > 40 else short_info['title']
            self.safe_ui(self.current_status.config, text=f"üì• ƒêang t·∫£i: {short_title}")
            self.safe_ui(self.current_progress.configure, value=0)
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                quality = self.quality_var.get()
                self.safe_ui(self.log, f"üì• [{total_index}] yt-dlp t·∫£i ({quality}): {short_info['title']}")
                try:
                    ydl.download([short_info['url']])
                except Exception:
                    self.safe_ui(self.log, f"‚ö†Ô∏è [{total_index}] L·ªói URL Shorts, th·ª≠ URL watch...")
                    ydl.download([short_info['watch_url']])
                
                self.safe_ui(self.update_tree_status, index, "Ho√†n th√†nh")
                self.safe_ui(self.log, f"‚úÖ [{total_index}] Ho√†n th√†nh: {short_info['title']}")
                return True
        
        except Exception as e:
            self.safe_ui(self.update_tree_status, index, "L·ªói")
            self.safe_ui(self.log, f"‚ùå [{total_index}] L·ªói: {e}")
            return False
    
    def download_range(self):
        if not self.shorts_list:
            messagebox.showwarning("‚ùå L·ªói", "Vui l√≤ng l·∫•y danh s√°ch Shorts tr∆∞·ªõc!")
            return
        try:
            start_idx = int(self.start_var.get()) - 1
            end_idx = int(self.end_var.get())
            if start_idx < 0 or end_idx > len(self.shorts_list) or start_idx >= end_idx:
                messagebox.showwarning("‚ùå L·ªói", "S·ªë th·ª© t·ª± kh√¥ng h·ª£p l·ªá!")
                return
        except ValueError:
            messagebox.showwarning("‚ùå L·ªói", "Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá!")
            return
        
        def download_task():
            download_path = self.path_var.get().strip() or self.download_path
            os.makedirs(download_path, exist_ok=True)
            
            total = end_idx - start_idx
            done = 0
            self.safe_ui(self.overall_progress.configure, maximum=total, value=0)
            
            quality = self.quality_var.get()
            container = self.format_var.get()
            audio_choice = self.audio_var.get()
            self.safe_ui(self.log, f"üöÄ B·∫Øt ƒë·∫ßu t·∫£i t·ª´ video {start_idx + 1} ƒë·∫øn {end_idx}")
            self.safe_ui(self.log, f"‚öôÔ∏è Settings: {quality}, {container}, Audio: {audio_choice}, Cookies: {'C√≥' if self.cookies_path else 'Kh√¥ng'}")
            self.safe_ui(self.overall_status.config, text=f"üì• ƒêang t·∫£i 0/{total} video...")
            
            for i in range(start_idx, end_idx):
                if self.download_short(self.shorts_list[i], i, i + 1):
                    done += 1
                progress = i - start_idx + 1
                self.safe_ui(self.overall_progress.configure, value=progress)
                self.safe_ui(self.overall_status.config, text=f"üì• ƒêang t·∫£i {progress}/{total} video...")
            
            self.safe_ui(self.overall_status.config, text=f"üéâ Ho√†n th√†nh! {done}/{total} video")
            self.safe_ui(self.current_status.config, text="")
            self.safe_ui(self.current_progress.configure, value=0)
            self.safe_ui(self.log, f"üéâ Xong! {done}/{total} video v·ªÅ {download_path}")
            messagebox.showinfo("üéâ Ho√†n th√†nh", f"ƒê√£ t·∫£i {done}/{total} video Shorts th√†nh c√¥ng!")
        
        threading.Thread(target=download_task, daemon=True).start()
    
    def download_all(self):
        if not self.shorts_list:
            messagebox.showwarning("‚ùå L·ªói", "Vui l√≤ng l·∫•y danh s√°ch Shorts tr∆∞·ªõc!")
            return
        self.start_var.set("1")
        self.end_var.set(str(len(self.shorts_list)))
        self.download_range()


if __name__ == "__main__":
    root = tk.Tk()
    app = ShortsDownloader(root)
    root.mainloop()
